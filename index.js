var C=(o,t)=>()=>(t||o((t={exports:{}}).exports,t),t.exports);var S=C((v,$)=>{function f(o){let t="";for(let s in o){let i=o[s];for(let e in i){let n=[e];e.includes("$")&&(n=e.split("$"));let r=i[e];for(let c in r){let a=r[c],p=c,u=!1;c.endsWith("!")&&(u=!0,p=c.split("!")[0]);let d=n.map(A=>`${A}:${a}${u?" !important":""}`).join(";");t+=`.${s.startsWith("$")?"":s}${p}{${d}}`}}}return t}function l(o){let t="";for(let s in o){let i=o[s],{css:e,actions:n}=i;if(e){let r=g(e);t+=`.${s}{${r}}`}if(n)for(let r in n){let c=n[r];t+=`.${s}:${r}{${g(c)}}`}}return t}function g(o){return o?Object.entries(o).map(([t,s])=>`${t}:${s}`).join(";"):""}$.exports={parse:function(o){let{atomic:t,utils:s}=o,i="";return t&&(i+=f(t)),s&&(i+=l(s)),i},parseAtomic:f,parseUtils:l}});var w=require("fs"),m=require("path"),y=S(),{PurgeCSS:E}=require("purgecss"),h=class{options={version:4,config:"",assets:"",publicPath:"/",importWay:"inline",parser:null};CSS_ASSET_NAME="atomic";cssContent="";constructor(t){for(let s in t)t[s]&&(this.options[s]=t[s]);if(this.options.parser)if(typeof this.options.parser=="function")this.cssContent=this.options.parser(this.getConfig());else throw new Error("Customizer parser should be function,which params is config");else this.cssContent=y.parse(this.getConfig())}getConfig(){if(!this.options.config)throw new Error("config path is required, please check.");if(this.options.config){if(!w.existsSync(this.options.config))throw new Error("config path is not valid, please check.");return require(this.options.config)}}getAssetsPath(t,s=!1){let{assets:i,publicPath:e}=this.options,n=s?`${e}${i}`:i;return t?`${n}/${this.CSS_ASSET_NAME}.${t}.css`:`${n}/${this.CSS_ASSET_NAME}.css`}apply(t){let s=h.name;if(!this.options.version)throw new Error("Please make sure you specify the version field.");if(this.options.version=="5"){let{Compilation:i,sources:e}=t.webpack;t.hooks.thisCompilation.tap(s,n=>{n.hooks.processAssets.tap({name:s,stage:i.PROCESS_ASSETS_STAGE_SUMMARIZE},async r=>{await this.purge(r),this.emitAsset(n,e),this.updateAssets(r,n,e),this.writeFile()})})}else if(this.options.version=="4")t.hooks.emit.tapAsync(s,(i,e)=>{let n=i.assets;this.purge(n).then(()=>{this.emitAsset(i),this.updateAssets(n,i),this.writeFile(),e()})});else throw new Error(`Doesn't support webpack version ${this.options.version}.`)}emitAsset(t,s){this.options.importWay==="link"&&t.emitAsset(this.getAssetsPath(t.hash),this.getSource(this.cssContent,s))}updateAssets(t,s,i){Object.keys(t).filter(e=>e.endsWith(".html")).forEach(e=>{let n=t[e].source(),[r,c]=n.split("</head>"),a=`${r}${this.getMiddlePart(s.hash)}</head>${c}`;s.updateAsset(e,this.getSource(a,i))})}writeFile(){w.writeFileSync(m.resolve(__dirname,".atomic.css"),this.cssContent)}getSource(t,s){if(this.options.version=="4")return{source:()=>t,size:()=>t.length};if(this.options.version=="5")return new s.RawSource(t)}getMiddlePart(t){let s=`<link type="text/css" rel="stylesheet" href="${this.getAssetsPath(t,!0)}">`;switch(this.options.importWay){case"link":return s;case"inline":return`<style type="text/css">${this.cssContent}</style>`;default:return s}}async purge(t){let s=Object.keys(t).filter(e=>e.endsWith(".js")||e.endsWith(".html")).map(e=>{let n=e.split(".").pop();return{raw:t[e].source(),extension:n}}),i=await new E().purge({content:s,css:[{raw:this.cssContent}]});this.cssContent=i.map(e=>e.css).join("")}};module.exports=h;exports.default=h;
